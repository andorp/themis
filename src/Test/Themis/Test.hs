{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
module Test.Themis.Test (
    Assertion(..)
  , assertionCata
  , TestName
  , Test
  , TestCase
  , TestSet
  , testCaseCata
  , testSetCata
  , test
  , shrink
  , group
  , runTest
  , module Test.QuickCheck.Gen
  ) where

import           Control.Applicative
import           Control.Monad
import           Control.Monad.Trans
import           Control.Monad.Identity
import           Control.Monad.Writer
import qualified Control.Monad.Trans.Writer as CMW

import           Test.QuickCheck.Gen

-- Simple test abtraction
data Assertion a
  -- Values must be equals, in order: expected, found, message
  = Equals a a String
  -- The given value must be satisfy the given predicate
  | Satisfies (a -> Bool) a String
  -- The given predicate must be true for every possible value generated by
  -- the given generator
  | Property (a -> Bool) (Gen a) String
  -- Evaluationg the given expression should an error thrown
  | Error a String

instance (Show a) => Show (Assertion a) where
  show = assertionCata equals satisfies property err
    where
      equals x y msg     = concat ["Equals ", show x, " ", show y, " ", msg]
      satisfies _p y msg = concat ["Satisfies [property] ", show y, " ", msg]
      property _p _g msg = concat ["Property ", msg]
      err _v         msg = concat ["Error ", msg]

assertionCata
  equals
  satisfies
  property
  err
  a = case a of
    Equals    expected found msg -> equals    expected found msg
    Satisfies prop     found msg -> satisfies prop     found msg
    Property  prop     gen   msg -> property  prop     gen   msg
    Error     value          msg -> err       value          msg

-- Test Name is a non-empty string for a test case
type TestName = String

data TestCase
  = forall a . (Show a, Eq a) => TestCase (TestName, Assertion a)
  -- ^ A test case that can be evaulated somehow
  | Shrink TestCase [TestCase]
  -- ^ If the test case passes, the rest of the tests would skipped
  -- ^ otherwise they evaulated to locate the problem
  | TestGroup TestName [TestCase]
  -- ^ A named group of test cases

testCase name assertion = TestCase (name, assertion)

testCaseCata
  :: (TestName -> forall a . (Show a, Eq a) => Assertion a -> b)
  -> (b -> [b] -> b)
  -> (TestName -> [b] -> b)
  -> TestCase
  -> b
testCaseCata testcase shrink group t = case t of
  TestCase (name, assertion) -> testcase name assertion
  Shrink test tests          -> shrink (testCaseCata' test) (map testCaseCata' tests)
  TestGroup name tests       -> group name (map testCaseCata' tests)
  where
    testCaseCata' = testCaseCata testcase shrink group

-- Test Set is a set of test cases, which elements will be
-- evaulated some of the test case runners
type TestSet = [TestCase]

testSetCata f ts = f ts

-- Creates a singleton test set, from the given test case
singleton :: TestCase -> TestSet
singleton t = [t]

-- * Monadic interface

-- Monadic abstraction for building test set.
newtype Test a = Test { unTest :: CMW.WriterT TestSet Identity a }
  deriving ( Functor
           , Applicative
           , MonadWriter TestSet
           , Monad
           )

-- * Primitives

-- Build a test set from the given test computation
buildTestSet :: Test b -> TestSet
buildTestSet = snd . runIdentity . runWriterT . unTest

-- Builds a test set and evaulates with the given evaluator
runTest :: (TestSet -> a) -> Test b -> a
runTest eval = eval . buildTestSet

-- Creates a test case with the given name and the given assertion
test :: (Eq a, Show a) => TestName -> Assertion a -> Test ()
test name assertion = tell . singleton $ testCase name assertion

-- * Combinators

-- Define the test case that can shrink to one or more sub cases
shrink :: (Eq a, Show a) => TestName -> Assertion a -> Test b -> Test ()
shrink name assertion shrinks = tell . singleton $ Shrink (testCase name assertion) (buildTestSet shrinks)

group :: TestName -> Test b -> Test ()
group name tests = tell . singleton $ TestGroup name (buildTestSet tests)
